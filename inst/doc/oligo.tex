%\VignetteIndexEntry{Oligo Vignette}
%\VignetteDepends{oligo, hapmap100kxba, geneplotter}
%\VignetteKeywords{Expression, SNP, Affymetrix, NimbleGen, Oligonucleotide Arrays}
%\VignettePackage{oligo}
\documentclass{article}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\oligo}{\Rpackage{oligo }}

\usepackage{graphicx}

\usepackage{/Users/seth/proj/builds/R-2.6/share/texmf/Sweave}
\begin{document}
\title{An Introduction to the Oligo Package}
\date{March, 2007}
\author{Benilton Carvalho}
\maketitle


\section{Introduction}

The \oligo package is designed to support all microarray designs
provided by Affymetrix and NimbleGen: expression, tiling, SNP and exon
arrays. With the increase in the density of the current technologies,
\oligo uses the resources offered by the \Rpackage{BufferedMatrix}
packages to handle the feature-level information. As of now,
chip-specific packages are built via \Rpackage{makePlatformDesign} and
transitioning to the \Rpackage{pdInfoBuilder} package, which creates
the data packages for the Affymetrix SNP arrays.

\section{Analyzing Affymetrix SNP Arrays}

Genotyping can be performed using \oligo and you will need:

\begin{itemize}
\item \oligo and its dependencies;
\item Chip specific data package, eg. \Rpackage{pd.mapping50k.xba240}:
  package that contains the array specifications and SNP annotation.
\item CEL files.
\end{itemize}

Figure \ref{workflow} shows the general workflow for genotyping using
the \oligo package. 

\begin{figure}[h]
  \centering
  \includegraphics[scale=.5]{workflow.png}
  \caption{Genotyping workflow using the \oligo package.}
  \label{workflow}
\end{figure}

We will start by loading the \oligo package and importing the CEL
files available on the \Rpackage{sampleDataAffy100K}. The intensity
matrix will be a \Rclass{BufferedMatrix} object and this will require
the use of temporary files in order to reduce the RAM usage. Although
the temporary files can be stored anywhere, a better approach will be
to use a local directory rather than using a directory on the
network. The \Robject{tmpdir} in the \Rfunction{read.celfiles()} sets
the directory where the temporary files are going to be stored.

\begin{Schunk}
\begin{Sinput}
R> library("oligo")
R> library("hapmap100kxba")
R> pathCelFiles <- system.file("celFiles", package = "hapmap100kxba")
R> fullFilenames <- list.celfiles(path = pathCelFiles, 
     full.names = TRUE)
R> temporaryDir <- tempdir()
R> preProcessedData <- justSNPRMA(fullFilenames, 
     tmpdir = temporaryDir)
\end{Sinput}
\begin{Soutput}
Calculating Expression
\end{Soutput}
\end{Schunk}

The SNPRMA approach described in \cite{Carvalho2006} is implemented in the
\Rmethod{justSNPRMA} methods (see Figure \ref{snprma}), which
preprocessess the CEL files in a more effective way in terms of memory
management. It returns a \Rclass{SnpQSet} object without creating a
\Rclass{SnpFeatureSet object}. The \Rclass{SnpQSet} object contains
the summarized data.

\begin{figure}[h]
  \centering
  \includegraphics[scale=.5]{snprma.png}
  \caption{SNPRMA overview}
  \label{snprma}
\end{figure}


For each SNP there are four numbers $(\theta_{A-}, \theta_{B-},
\theta_{A+}, \theta_{B+})$, which are proportional to the
log-intensities in each of these combinations of allele and strand
($-$: antisense; $+$: sense). They are represented by four matrices:
\Robject{antisenseThetaA}, \Robject{antisenseThetaB},
\Robject{senseThetaA} and \Robject{senseThetaB}, which are the
components of the \Rclass{SnpQSet} object. One can extract these
objects using accessors of the same name.

Average intensities and log-ratios are defined as across allele and
within strand, ie:
\begin{eqnarray}
  A_{s} & = & \frac{\theta_{A, s}+\theta_{B, s}}{2} \\
  M_{s} & = & \theta_{A, s} - \theta_{B, s},
\end{eqnarray}
where $s$ defines the strand (antisense or sense). These quantities
can be obtained via \Rmethod{getA()} and \Rmethod{getM} methods, which
return high-dimensional arrays with dimensions corresponding to SNP's,
samples and strands, respectively.
\begin{Schunk}
\begin{Sinput}
R> theA <- getA(preProcessedData)
R> theM <- getM(preProcessedData)
R> dim(theA)
\end{Sinput}
\begin{Soutput}
[1] 58960     3     2
\end{Soutput}
\begin{Sinput}
R> str(theM)
\end{Sinput}
\begin{Soutput}
 num [1:58960, 1:3, 1:2] -2.309 -3.231 -2.616 -0.126 -1.406 ...
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:58960] "SNP_A-1507972" "SNP_A-1510136" "SNP_A-1511055" "SNP_A-1518245" ...
  ..$ : chr [1:3] "CEU_NA06985_XBA.CEL.gz" "CEU_NA06991_XBA.CEL.gz" "CEU_NA06993_XBA.CEL.gz"
  ..$ : chr [1:2] "antisense" "sense"
\end{Soutput}
\end{Schunk}

These measures can be used, for example, to create an MA-plot and are
later used for genotyping. The example below generates an MA-plot for
the first sample using only the antisense strand data:
\begin{Schunk}
\begin{Sinput}
R> library("geneplotter")
R> smoothScatter(theA[, 1, 1], theM[, 1, 1], main = "MA-plot (Antisense)", 
     xlab = "Average Intensity", ylab = "Log-ratio (A/B)")
\end{Sinput}
\end{Schunk}
\includegraphics{oligo-maplot}

The CRLMM algorithm \cite{Carvalho2006} can be applied on a
\Rclass{SnpQSet} object in order to produce genotype calls. It involves
running a mixture of regressions via EM algorithm to adjust for average
intensity and fragment length in the log-ratio scale. These adjustments
may take long time to run, depending on the combination of number of
samples and computer resources available. To save time in subsequent
analyses, we must specify the name of the file that will store the
results obtained with the EM algorithm using the
\Robject{correctionFile} argument. If the file passed to
\Robject{correctionFile} does not exist, it is created, otherwise it is
loaded. Figure \ref{crlmm} presents a diagram of the CRLMM algorithm:

\begin{figure}[h]
  \centering
  \includegraphics[scale=.5]{crlmm.png}
  \caption{CRLMM Algorithm diagram}
  \label{crlmm}
\end{figure}

\textbf{A word of warning}: the \Rmethod{crlmm()} method searches for a
variable \Robject{gender} in the \Rclass{phenoData} slot of the
\Rclass{SnpQSet} object. If it fails to find that variable, it will try
estimate the gender from the data. If there is not enough discrimination
power to estimate the gender, the following error message will be
returned:

{\bf empty cluster: try a better set of initial centers}

Increasing the sample size is one of the possible solutions, although
the preferred one is to have \Robject{gender} already defined in the
\Rclass{phenoData} slot.

The \Rclass{phenoData} slot includes covariates about the
samples. Genotyping and copy number analyses often make use of gender
information in order to provide more precise inferences. The code
below exemplifies the creation of the \Rclass{phenoData} object.

\begin{Schunk}
\begin{Sinput}
R> aboutSamples <- data.frame(gender = c("female", 
     "female", "male"))
R> rownames(aboutSamples) <- sampleNames(preProcessedData)
R> aboutVars <- data.frame(labelDescription = "male/female")
R> rownames(aboutVars) <- "gender"
R> phenoData(preProcessedData) <- new("AnnotatedDataFrame", 
     data = aboutSamples, varMetadata = aboutVars)
\end{Sinput}
\end{Schunk}

\begin{Schunk}
\begin{Sinput}
R> crlmmOut <- crlmm(preProcessedData, correctionFile = "exampleCorrection.rda", 
     verbose = FALSE)